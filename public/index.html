<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Geetham e-Exam</title>
<link rel="icon" type="image/jpeg" href="/geetham.jpg" />
<link rel="manifest" href="/manifest.json" />
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<meta name="theme-color" content="#0056b3"/>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 10px; }
    .main-container, #student-details-screen { display: none; }
    .quiz-panel { flex-grow: 1; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .sidebar { width: 300px; margin-left: 20px; background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    h1, h2 { color: #0056b3; text-align: center; }
    input, select { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box; }
    #timer { font-size: 20px; font-weight: bold; color: #d9534f; text-align: center; margin-bottom: 15px; }
    .subject-tabs { display: flex; border-bottom: 2px solid #ddd; margin-bottom: 20px; gap: 10px; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .subject-tab { padding: 10px 20px; cursor: pointer; font-weight: 600; border: none; background-color: #f0f2f5; color: #333; font-size: 16px; border-radius: 8px 8px 0 0; }
    .subject-tab.active { background-color: #007bff; color: white; }
    .question-area { min-height: 300px; }
    .option { display: block; margin: 10px 0; padding: 12px; border: 1px solid #ddd; border-radius: 5px; cursor: pointer; }
    .option.selected { background-color: #007bff; color: white; border-color: #007bff; }
    .nav-buttons { margin-top: 20px; display: flex; justify-content: space-between; }
    button { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
    button:disabled { background-color: #a0a0a0; }
    .palette-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; }
    .palette-item { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; font-weight: bold; }
    .status-not-answered { background-color: #f0f0f0; }
    .status-answered { background-color: #28a745; color: white; }
    .status-review { background-color: #ffc107; }
    #camera-wrapper { position: fixed; bottom: 10px; left: 10px; width: 160px; height: 120px; border: 2px solid #0056b3; border-radius: 6px; background: #000; overflow: hidden; display: none; z-index: 9998; resize: both; }
    #camera-header { height: 22px; background: rgba(0,86,179,0.9); color: #fff; display:flex; align-items:center; justify-content:center; padding: 0 6px; cursor: move; font-size: 12px; }
    #camera-view { width:100%; height: calc(100% - 22px); object-fit: cover; display:block; }
    .toast { position: fixed; top: -100px; left: 50%; transform: translateX(-50%); padding: 15px 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); font-size: 16px; font-weight: bold; z-index: 100000; opacity: 0; transition: opacity 0.5s, top 0.5s; }
    .toast.show { top: 40px; opacity: 1; }
    .toast.warning { background-color: #dc3545; color: white; }
    .toast.success { background-color: #28a745; color: white; }
    #warnings-indicator { position: fixed; top: 14px; right: 14px; background: #ffc107; color: #333; padding: 6px 10px; border-radius: 18px; font-weight: 700; z-index: 9999; }
    #ai-status { position: fixed; top: 14px; left: 14px; padding: 6px 10px; border-radius: 18px; font-weight: 700; z-index: 9999; font-size: 12px; }
    #ai-status.loading { background: #ffc107; color: #333; }
    #ai-status.ready { background: #28a745; color: white; }
    #ai-status.error { background: #dc3545; color: white; }
    #save-status { text-align: right; padding: 10px 0 5px; font-size: 12px; font-weight: 500; color: green; height: 15px; }
    #save-status.flash { animation: flashGreen 1s ease; }
    @keyframes flashGreen {
        0%   { opacity: 0.3; }
        50%  { opacity: 1; }
        100% { opacity: 0.8; }
    }
</style>
</head>
<body>
<div id="fullscreen-warning" style="display:none; flex-direction: column; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: white; z-index: 10000;">
    <h1>You Exited Full-Screen!</h1>
    <p>Please return to full-screen to continue the test.</p>
    <p>Resuming automatically in <span id="fullscreen-countdown">5</span> seconds...</p>
    <button id="resume-fullscreen-btn">Resume Full-Screen</button>
</div>
<div id="ai-status" class="loading" style="display:none;">AI Proctor Loading...</div>
<div id="warnings-indicator" title="Warnings" style="display:none;">Warnings: <span id="warning-count">0</span></div>
<div id="camera-wrapper">
    <div id="camera-header"><span>Camera</span></div>
    <video id="camera-view" autoplay playsinline muted></video>
</div>
<div id="student-details-screen" style="display: block;">
    <div style="max-width: 500px; margin: 50px auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <div style="text-align: center; margin-bottom: 15px;">
            <img src="/geetham.jpg" alt="Geetham Institute Logo" style="max-height: 80px;">
        </div>
        <h1>Geetham e-Exam</h1>
        <div id="login-form">
            <h2>Enter Your Details</h2>
            <p>You can only attempt each test once.</p>
            <div id="quiz-selection-container"></div>
            <input type="text" id="student-name" placeholder="Enter your full name" required autocomplete="off">
            <input type="tel" id="student-mobile" placeholder="Enter your mobile number" required autocomplete="off">
            <button id="proceed-btn" style="width: 100%;">Proceed</button>
        </div>
    </div>
</div>
<div id="warningBanner" style="display:none; background:#ff4d4d; color:white; padding:10px; text-align:center; font-weight:bold;">Last 5 minutes remaining! Please finish your quiz.</div>
<div class="main-container" id="quiz-screen">
    <div class="quiz-panel">
        <h1 style="margin-top: 0;" id="quiz-title-main"></h1>
        <div id="timer">00:00:00</div>
        <div class="subject-tabs"></div>
        <div id="question-area" class="question-area"></div>
        <div class="nav-buttons">
            <button class="secondary" onclick="markForReview()">Mark for Review & Next</button>
            <div>
                <button id="manual-save-btn" class="secondary" onclick="manualSave()">Save Progress</button>
                <button onclick="goPrevious()">Previous</button>
                <button class="secondary" onclick="clearResponse()">Clear Response</button>
                <button onclick="saveAndNext()">Save & Next</button>
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="submit" onclick="confirmSubmit()">Submit Test</button>
        </div>
    </div>
    <div class="sidebar">
        <div id="save-status"></div>
        <h4>Question Palette</h4>
        <div id="question-palette" class="palette-grid"></div>
        <hr>
        <h4>Legend</h4>
        <div style="display:flex; align-items: center; margin-top: 10px;"><div class="palette-item status-answered"></div><span style="margin-left: 10px;">Answered</span></div>
        <div style="display:flex; align-items: center; margin-top: 10px;"><div class="palette-item status-review"></div><span style="margin-left: 10px;">Marked for Review</span></div>
        <div style="display:flex; align-items: center; margin-top: 10px;"><div class="palette-item status-not-answered"></div><span style="margin-left: 10px;">Not Answered</span></div>
    </div>
</div>
<script type="module">
import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

// --- GLOBAL VARIABLES ---
let allQuizzes = [], currentQuiz = {}, currentSubject = "", currentQuestionIndex = 0;
let userResponses = {}, studentDetails = {}, timerInterval, quizInProgress = false, warningCount = 0;
const maxWarnings = 3;
let faceLandmarker, isGazeDetectionRunning = false, lookAwayStartTime = null;
const LOOK_AWAY_THRESHOLD = 3000;
let questionTimes = {}, lastQuestionStart = null, fullscreenCountdownInterval;
let stateToResume = null; 

// --- UTILITY FUNCTIONS ---
function showToast(message, type = 'warning') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => { toast.classList.add('show'); }, 100);
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 500);
    }, 4000);
}

function updateAIStatus(status, message) {
    const aiStatus = document.getElementById('ai-status');
    aiStatus.className = status;
    aiStatus.textContent = message;
    aiStatus.style.display = 'block';
    if (status === 'ready') setTimeout(() => { aiStatus.style.display = 'none'; }, 3000);
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// --- QUIZ FLOW ---
async function loadInitialData() {
    try {
        const response = await fetch('/get-quizzes');
        allQuizzes = await response.json();
        displayInitialScreen();
    } catch (error) {
        document.body.innerHTML = "<h1>Error: Could not load quiz data.</h1>";
    }
}

function displayInitialScreen() {
    document.getElementById('student-details-screen').style.display = 'block';
    const quizSelectionContainer = document.getElementById('quiz-selection-container');
    let selectHTML = '<label for="quiz-select">Select a Test:</label><select id="quiz-select">';
    allQuizzes.forEach((quiz, index) => selectHTML += `<option value="${index}">${quiz.title}</option>`);
    selectHTML += '</select>';
    quizSelectionContainer.innerHTML = selectHTML;
    document.getElementById('proceed-btn').onclick = handleProceed;
}

async function handleProceed() {
    const name = document.getElementById('student-name').value.trim();
    const mobile = document.getElementById('student-mobile').value.trim();
    const quizSelect = document.getElementById('quiz-select');
    currentQuiz = allQuizzes[quizSelect ? quizSelect.value : 0];
    if (!name || !mobile) return alert("Please fill in all details.");
    studentDetails = { name, mobile };
    const storageKey = `examData_${studentDetails.mobile}_${currentQuiz.id}`;
    const savedData = localStorage.getItem(storageKey);
    if (savedData) {
        if (confirm("We found a saved session for this exam. Do you want to resume?")) {
            stateToResume = JSON.parse(savedData);
        }
    }
    const response = await fetch('/check-attempt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mobile: studentDetails.mobile, quizId: currentQuiz.id })
    });
    const data = await response.json();
    if (data.canAttempt) {
        showPasswordScreen();
    } else {
        alert(data.message);
    }
}

function showPasswordScreen() {
    const detailsScreen = document.getElementById('login-form');
    detailsScreen.innerHTML = `
        <h2>Enter Exam Password</h2>
        <input type="password" id="exam-password" placeholder="Enter the password" required autocomplete="new-password">
        <button id="password-submit-btn" style="width: 100%;">Continue</button>
    `;
    document.getElementById('password-submit-btn').onclick = () => {
        if (document.getElementById('exam-password').value === currentQuiz.password) {
            prepareQuiz();
        } else {
            alert("Incorrect password.");
        }
    };
}

function prepareQuiz() {
    loadGazeModel();
    const detailsContainer = document.getElementById('student-details-screen').querySelector('div');
    detailsContainer.innerHTML = `
        <h2>Exam Instructions</h2>
        <p>This test is AI-proctored. Do not switch tabs, exit full-screen, or look away.</p>
        <p>After ${maxWarnings} warnings, your test will be submitted automatically.</p>
        <p>Your progress will be saved automatically.</p>
        <button id="start-test-btn" style="width: 100%;">Start Camera & Full Screen</button>
    `;
    document.getElementById('start-test-btn').onclick = async () => {
        try {
            await startCamera();
            await requestFullscreenSafe();
            showToast("Permissions Granted!", "success");
            setTimeout(() => {
                document.getElementById('student-details-screen').style.display = 'none';
                document.getElementById('quiz-screen').style.display = 'flex';
                initializeQuiz();
            }, 1500);
        } catch (err) {
            showToast("Could not start. Please allow permissions.", "warning");
        }
    };
}

function initializeQuiz() {
    quizInProgress = true;
    document.getElementById('quiz-title-main').textContent = currentQuiz.title;
    const subjectTabsContainer = document.querySelector('.subject-tabs');
    subjectTabsContainer.innerHTML = '';
    let firstSubject = Object.keys(currentQuiz.subjects)[0];
    Object.keys(currentQuiz.subjects).forEach(subject => {
        const tab = document.createElement('button');
        tab.className = 'subject-tab';
        tab.textContent = subject;
        tab.onclick = (e) => switchSubject(subject, e.currentTarget);
        subjectTabsContainer.appendChild(tab);
    });
    let shouldResetIndex = true;
    if (stateToResume) {
        userResponses = stateToResume.userResponses;
        currentSubject = stateToResume.currentSubject;
        currentQuestionIndex = stateToResume.currentQuestionIndex;
        shouldResetIndex = false;
        firstSubject = currentSubject;
        stateToResume = null;
        showToast("Resumed your previous session!", "success");
    } else {
        Object.keys(currentQuiz.subjects).forEach(subject => {
            shuffleArray(currentQuiz.subjects[subject]);
            userResponses[subject] = {};
            questionTimes[subject] = {};
        });
        currentSubject = firstSubject;
    }
    setupProctoringListeners();
    const activeTab = [...subjectTabsContainer.querySelectorAll('.subject-tab')].find(t => t.textContent === firstSubject);
    switchSubject(firstSubject, activeTab, shouldResetIndex);
    startTimer(currentQuiz.timeLimit * 60);
    setTimeout(startGazeDetection, 2000);
    setInterval(() => autoSave("interval"), 30000);
}

function getExamState() {
    return {
        userResponses: userResponses,
        currentSubject: currentSubject,
        currentQuestionIndex: currentQuestionIndex,
    };
}

function autoSave(trigger = "auto") {
    if (!quizInProgress) return;
    const examState = getExamState();
    const storageKey = `examData_${studentDetails.mobile}_${currentQuiz.id}`;
    localStorage.setItem(storageKey, JSON.stringify(examState));
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    const saveStatus = document.getElementById('save-status');
    if (saveStatus) {
        saveStatus.textContent = `✔ Last saved: ${timeString} (${trigger})`;
        saveStatus.classList.remove("flash");
        void saveStatus.offsetWidth;
        saveStatus.classList.add("flash");
    }
}

function manualSave() {
    autoSave("manual");
    showToast("Progress Saved Manually!", "success");
}

function loadQuestion() {
    const question = currentQuiz.subjects[currentSubject][currentQuestionIndex];
    const questionArea = document.getElementById('question-area');
    questionArea.innerHTML = `
        <h3>Question ${currentQuestionIndex + 1}</h3>
        <p>${question.text}</p>
        <img style="display:${question.imageUrl ? 'block' : 'none'}; max-width:100%;" src="${question.imageUrl || ''}">
        <div id="options-container"></div>
    `;
    const optionsContainer = document.getElementById('options-container');
    const response = userResponses[currentSubject]?.[currentQuestionIndex] || {};
    if (question.type === "multiple-choice") {
        if (!question.shuffledOptions) {
            const originalCorrectAnswerText = question.options[question.correctAnswer];
            const shuffledOptions = [...question.options];
            shuffleArray(shuffledOptions);
            question.shuffledOptions = shuffledOptions;
            question.shuffledCorrectAnswerIndex = shuffledOptions.indexOf(originalCorrectAnswerText);
        }
        question.shuffledOptions.forEach((option, index) => {
            const div = document.createElement('div');
            div.className = 'option';
            div.textContent = option;
            if (response.answer === index) div.classList.add('selected');
            div.onclick = () => selectOption(index);
            optionsContainer.appendChild(div);
        });
    } else if (question.type === "fill-in-the-blank") {
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your answer here';
        input.value = response.answer || '';
        input.oninput = (e) => selectOption(e.target.value);
        optionsContainer.appendChild(input);
    } else if (question.type === "subjective") {
        const textarea = document.createElement('textarea');
        textarea.placeholder = 'Write your answer here';
        textarea.rows = 4;
        textarea.style.width = '100%';
        textarea.value = response.answer || '';
        textarea.oninput = (e) => selectOption(e.target.value);
        optionsContainer.appendChild(textarea);
    }
    lastQuestionStart = Date.now();
    updatePalette();
}

function selectOption(answer) {
    if (!userResponses[currentSubject]) userResponses[currentSubject] = {};
    const currentResponse = userResponses[currentSubject]?.[currentQuestionIndex] || {};
    currentResponse.answer = answer;
    if (currentResponse.status !== 'review') {
        currentResponse.status = 'answered';
    }
    userResponses[currentSubject][currentQuestionIndex] = currentResponse;
    if (currentQuiz.subjects[currentSubject][currentQuestionIndex].type === "multiple-choice") {
        document.querySelectorAll('.option').forEach((opt, optIndex) => {
            opt.classList.toggle('selected', optIndex === answer);
        });
    }
    updatePalette();
    autoSave("instant");
}

function switchSubject(subject, clickedTab, resetQuestionIndex = true) {
    accumulateTimeForCurrent();
    currentSubject = subject;
    if (resetQuestionIndex) {
        currentQuestionIndex = 0;
    }
    document.querySelectorAll('.subject-tab').forEach(tab => tab.classList.remove('active'));
    if (clickedTab) clickedTab.classList.add('active');
    loadQuestion();
}

function setupProctoringListeners() {
    document.addEventListener('fullscreenchange', handleFullscreenChangeEvent);
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && quizInProgress) {
            handleWarning("You have switched tabs.");
            autoSave("tab switch");
        }
    });
    window.addEventListener("blur", () => {
        if (quizInProgress) handleWarning("You have switched to another application.");
    });
    document.addEventListener('contextmenu', e => {
        if (quizInProgress) {
            e.preventDefault();
            handleWarning("Right-click is disabled.");
        }
    });
    document.addEventListener('keydown', e => {
        if (!quizInProgress) return;
        if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && ['I', 'J', 'C'].includes(e.key.toUpperCase()))) {
            e.preventDefault();
            handleWarning("Developer tools are disabled.");
        }
    });
    const resumeBtn = document.getElementById('resume-fullscreen-btn');
    if (resumeBtn) {
        resumeBtn.addEventListener('click', () => {
            clearInterval(fullscreenCountdownInterval);
            requestFullscreenSafe();
        });
    }
}

function handleFullscreenChangeEvent() {
    const overlay = document.getElementById('fullscreen-warning');
    if (!document.fullscreenElement && quizInProgress) {
        handleWarning("You have exited full-screen.");
        autoSave("fullscreen exit");
        overlay.style.display = 'flex';
        startFullscreenCountdown();
    } else {
        overlay.style.display = 'none';
        clearInterval(fullscreenCountdownInterval);
    }
}
function confirmSubmit() {
    if (!quizInProgress) return;
    if (confirm("Are you sure you want to submit the test? You cannot make any changes after this.")) {
        submitTest();
    }
}

function submitTest() {
    if (!quizInProgress) return;
    quizInProgress = false;
    clearInterval(timerInterval);
    autoSave("final");
    accumulateTimeForCurrent();

    const submitBtn = document.querySelector('.submit');
    if (submitBtn) submitBtn.disabled = true;

    // Compute total score (existing logic)
    let totalScore = 0;
    let subjectScores = {};
    Object.keys(currentQuiz.subjects).forEach(subject => {
        let subjectScore = 0;
        currentQuiz.subjects[subject].forEach((q, index) => {
            const response = userResponses[subject]?.[index];
            if (!response || response.answer === undefined || response.answer === '') return;
            let marksCorrect = currentQuiz.marksMode === 'custom' ? (q.correctMarks ?? 1) : (currentQuiz.correctMarks ?? 1);
            let marksIncorrect = currentQuiz.marksMode === 'custom' ? (q.wrongMarks ?? 0) : (currentQuiz.wrongMarks ?? 0);
            let isCorrect = false;
            if (q.type === "multiple-choice") isCorrect = (response.answer === q.shuffledCorrectAnswerIndex);
            else if (q.type === "fill-in-the-blank") {
                const correctAnswers = (q.answerKey || '').split('|').map(a => a.trim().toLowerCase());
                isCorrect = correctAnswers.includes((response.answer || '').toString().trim().toLowerCase());
            }
            subjectScore += isCorrect ? marksCorrect : marksIncorrect;
        });
        subjectScores[subject] = subjectScore;
        totalScore += subjectScore;
    });

    const sendResult = (location = { lat: null, lon: null }) => {
        const resultData = {
            date: new Date().toISOString(),
            studentName: studentDetails.name,
            mobile: studentDetails.mobile,
            quizId: currentQuiz.id,
            quizTitle: currentQuiz.title,
            totalScore,
            subjectScores,
            warnings: warningCount,
            questionTimes,
            location,
            responses: userResponses
        };
        fetch('/submit-result', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(resultData),
        })
        .then(res => {
            if (!res.ok) throw new Error('Submission failed');
            alert("Test Submitted Successfully!");
            localStorage.removeItem(`examData_${studentDetails.mobile}_${currentQuiz.id}`);
            document.getElementById('quiz-screen').innerHTML = `
                <div style="text-align:center; margin:50px auto;">
                    <h1>Thanks for taking Exam</h1>
                    <button onclick="downloadPDFReport()">Download Report</button>
                </div>`;
        })
        .catch(() => {
            alert('Submission failed. Your progress is saved, please contact support.');
            if (submitBtn) submitBtn.disabled = false;
        });
    };

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => sendResult({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
            () => sendResult({ lat: null, lon: null }),
            { timeout: 5000 }
        );
    } else {
        sendResult({ lat: null, lon: null });
    }
}


async function requestFullscreenSafe() {
    try {
        if (document.fullscreenElement) return;
        const el = document.documentElement;
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        else if (el.msRequestFullscreen) el.msRequestFullscreen();
    } catch (err) {
        console.error("Failed to enter full-screen:", err);
        throw err;
    }
}

function startFullscreenCountdown() {
    let seconds = 5;
    const countdownElement = document.getElementById('fullscreen-countdown');
    countdownElement.textContent = seconds;
    clearInterval(fullscreenCountdownInterval);
    fullscreenCountdownInterval = setInterval(async () => {
        if (document.fullscreenElement) {
            clearInterval(fullscreenCountdownInterval);
            document.getElementById('fullscreen-warning').style.display = 'none';
            return;
        }
        seconds--;
        countdownElement.textContent = seconds;
        if (seconds <= 0) {
            clearInterval(fullscreenCountdownInterval);
            await requestFullscreenSafe().catch(() => {
                showToast("Please click Resume Full-Screen to continue.", "warning");
            });
        }
    }, 1000);
}

function handleWarning(message) {
    warningCount++;
    const warningMessage = `Warning ${warningCount}/${maxWarnings}: ${message}`;
    showToast(warningMessage, 'warning');
    document.getElementById('warning-count').textContent = warningCount;
    document.getElementById('warnings-indicator').style.display = 'block';
    if (warningCount >= maxWarnings) {
        setTimeout(() => {
            showToast(`Maximum warnings exceeded. Submitting test automatically.`, 'warning');
            submitTest();
        }, 1000);
    }
}

async function startCamera() {
    const videoElement = document.getElementById('camera-view');
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = stream;
        document.getElementById('camera-wrapper').style.display = 'block';
        await new Promise(resolve => videoElement.onloadedmetadata = resolve);
    } else { throw new Error("Camera not supported."); }
}

async function loadGazeModel(retries = 2) {
    updateAIStatus('loading', 'Loading AI Proctor...');
    try {
        const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
        faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numFaces: 1
        });
        updateAIStatus('ready', 'AI Proctor Ready');
    } catch (error) {
        console.error("Failed to load gaze model:", error);
        if (retries > 0) setTimeout(() => loadGazeModel(retries - 1), 2000);
        else updateAIStatus('error', 'AI Proctor Failed');
    }
}

function startGazeDetection() {
    if (!faceLandmarker || isGazeDetectionRunning) return;
    isGazeDetectionRunning = true;
    const video = document.getElementById('camera-view');
    let lastVideoTime = -1;
    async function predictWebcam() {
        if (!quizInProgress) return;
        const startTimeMs = performance.now();
        if (video.readyState >= 2 && lastVideoTime !== video.currentTime) {
            lastVideoTime = video.currentTime;
            const results = faceLandmarker.detectForVideo(video, startTimeMs);
            let isLookingAway = !results.faceLandmarks || results.faceLandmarks.length === 0;

            if (results.faceLandmarks && results.faceLandmarks.length > 1) {
                handleWarning("Multiple faces detected.");
            }
            if (isLookingAway) {
                if (lookAwayStartTime === null) lookAwayStartTime = Date.now();
                else if (Date.now() - lookAwayStartTime > LOOK_AWAY_THRESHOLD) {
                    handleWarning("Looking away or face not detected.");
                    lookAwayStartTime = null;
                }
            } else {
                lookAwayStartTime = null;
            }
        }
        window.requestAnimationFrame(predictWebcam);
    }
    predictWebcam();
}

function accumulateTimeForCurrent() {
    if (!quizInProgress || lastQuestionStart === null) return;
    const elapsed = Date.now() - lastQuestionStart;
    if (!questionTimes[currentSubject]) questionTimes[currentSubject] = {};
    questionTimes[currentSubject][currentQuestionIndex] = (questionTimes[currentSubject][currentQuestionIndex] || 0) + elapsed;
}

function goPrevious() {
    accumulateTimeForCurrent();
    const subjects = Object.keys(currentQuiz.subjects);
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
    } else {
        const currentSubjectIndex = subjects.indexOf(currentSubject);
        if (currentSubjectIndex > 0) {
            const prevSubject = subjects[currentSubjectIndex - 1];
            currentSubject = prevSubject;
            currentQuestionIndex = currentQuiz.subjects[prevSubject].length - 1;
            document.querySelectorAll('.subject-tab').forEach(tab => tab.classList.remove('active'));
            const newActiveTab = [...document.querySelectorAll('.subject-tab')].find(t => t.textContent === currentSubject);
            if (newActiveTab) newActiveTab.classList.add('active');
        } else {
            return; // At the very first question, do nothing
        }
    }
    loadQuestion();
}

function goNext() {
    accumulateTimeForCurrent();
    const subjects = Object.keys(currentQuiz.subjects);
    const currentSubjectIndex = subjects.indexOf(currentSubject);
    if (currentQuestionIndex < currentQuiz.subjects[currentSubject].length - 1) {
        currentQuestionIndex++;
    } else if (currentSubjectIndex < subjects.length - 1) {
        const nextSubject = subjects[currentSubjectIndex + 1];
        currentSubject = nextSubject;
        currentQuestionIndex = 0;
        document.querySelectorAll('.subject-tab').forEach(tab => tab.classList.remove('active'));
        const newActiveTab = [...document.querySelectorAll('.subject-tab')].find(t => t.textContent === currentSubject);
        if (newActiveTab) newActiveTab.classList.add('active');
    } else {
        showToast("You are at the last question. Click submit to finish.", "info");
        return;
    }
    loadQuestion();
}

function saveAndNext() {
    const question = currentQuiz.subjects[currentSubject][currentQuestionIndex];
    const response = userResponses[currentSubject]?.[currentQuestionIndex] || {};
    let isAnswered = true;
    if (question.type === 'multiple-choice') {
        if (response.answer === undefined) isAnswered = false;
    } else if (question.type === 'fill-in-the-blank' || question.type === 'subjective') {
        if (!response.answer || response.answer.trim() === '') isAnswered = false;
    }
    if (!isAnswered) {
        userResponses[currentSubject][currentQuestionIndex] = { ...response, status: 'not-answered' };
    } else {
        userResponses[currentSubject][currentQuestionIndex] = { ...response, status: 'answered' };
    }
    goNext();
}

function markForReview() {
    if (!userResponses[currentSubject]) userResponses[currentSubject] = {};
    userResponses[currentSubject][currentQuestionIndex] = {
        ...(userResponses[currentSubject][currentQuestionIndex] || {}),
        status: 'review'
    };
    goNext();
}

function clearResponse() {
    if (userResponses[currentSubject] && userResponses[currentSubject][currentQuestionIndex]) {
        delete userResponses[currentSubject][currentQuestionIndex];
    }
    const question = currentQuiz.subjects[currentSubject][currentQuestionIndex];
    if (question.type === "multiple-choice") {
        document.querySelectorAll('.option.selected').forEach(el => el.classList.remove('selected'));
    } else if (question.type === "fill-in-the-blank" || question.type === "subjective") {
        const input = document.querySelector('#options-container input, #options-container textarea');
        if (input) input.value = '';
    }
    updatePalette();
}

function updatePalette() {
    const palette = document.getElementById('question-palette');
    let totalQuestions = 0;
    Object.values(currentQuiz.subjects).forEach(s => totalQuestions += s.length);
    if (palette.childElementCount !== totalQuestions) {
        palette.innerHTML = '';
        const allSubjects = Object.keys(currentQuiz.subjects);
        let qNum = 1;
        allSubjects.forEach(subjectName => {
            const subjectQuestions = currentQuiz.subjects[subjectName];
            subjectQuestions.forEach((_, qIndex) => {
                const item = document.createElement('div');
                item.className = 'palette-item status-not-answered';
                item.textContent = qNum;
                item.dataset.qIndex = qIndex;
                item.dataset.subject = subjectName;
                item.onclick = () => {
                    accumulateTimeForCurrent();
                    currentSubject = subjectName;
                    currentQuestionIndex = qIndex;
                    const activeTab = [...document.querySelectorAll('.subject-tab')].find(t => t.textContent === subjectName);
                    if (activeTab) {
                        document.querySelectorAll('.subject-tab').forEach(t => t.classList.remove('active'));
                        activeTab.classList.add('active');
                    }
                    loadQuestion();
                };
                palette.appendChild(item);
                qNum++;
            });
        });
    }
    let globalIndex = 0;
    Object.keys(currentQuiz.subjects).forEach(subjectName => {
        const questions = currentQuiz.subjects[subjectName];
        questions.forEach((q, qIndex) => {
            const status = userResponses[subjectName]?.[qIndex]?.status || 'not-answered';
            const item = palette.children[globalIndex];
            if (item) {
                item.className = 'palette-item';
                if (status === 'answered') item.classList.add('status-answered');
                else if (status === 'review') item.classList.add('status-review');
                else item.classList.add('status-not-answered');
            }
            globalIndex++;
        });
    });
}

function startTimer(durationInSeconds) {
    let timer = durationInSeconds;
    const display = document.getElementById('timer');
    timerInterval = setInterval(() => {
        let hours = Math.floor(timer / 3600);
        let minutes = Math.floor((timer % 3600) / 60);
        let seconds = timer % 60;
        hours = hours < 10 ? "0" + hours : hours;
        minutes = minutes < 10 ? "0" + minutes : minutes;
        seconds = seconds < 10 ? "0" + seconds : seconds;
        display.textContent = `${hours}:${minutes}:${seconds}`;
        if (timer <= 300) {
            document.getElementById('warningBanner').style.display = 'block';
        }
        if (--timer < 0) {
            clearInterval(timerInterval);
            submitTest();
        }
    }, 1000);
}


    // ⬇ Add this block near the end of your module, after the function definitions
    function downloadPDFReport() {
    if (!currentQuiz || !userResponses) return alert("No exam data available.");

    const doc = new window.jspdf.jsPDF();
    const doc = new jsPDF();
    let y = 10;

    // Header
    doc.setFillColor(0, 86, 179);
    doc.rect(0, 0, 210, 20, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(16);
    doc.text("Geetham e-Exam Report", 105, 14, { align: "center" });
    y += 25;

    // Student Info
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text(`Student Name: ${studentDetails.name}`, 10, y);
    y += 7;
    doc.text(`Mobile: ${studentDetails.mobile}`, 10, y);
    y += 7;
    doc.text(`Quiz Title: ${currentQuiz.title}`, 10, y);
    y += 7;
    doc.text(`Date: ${new Date().toLocaleString()}`, 10, y);
    y += 10;

    let totalScore = 0;

    Object.keys(currentQuiz.subjects).forEach(subject => {
        // Subject Header
        doc.setFillColor(0, 123, 255);
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(14);
        doc.rect(10, y - 4, 190, 8, 'F');
        doc.text(subject, 12, y);
        y += 10;

        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);

        let subjectScore = 0;

        // Table header
        doc.setFillColor(200, 200, 200);
        doc.rect(10, y - 4, 190, 8, 'F');
        doc.setTextColor(0, 0, 0);
        doc.text("Q#", 12, y);
        doc.text("Question", 20, y);
        doc.text("Your Answer", 110, y);
        doc.text("Correct Answer", 160, y);
        doc.text("Marks", 190, y, { align: 'right' });
        doc.text("Time (s)", 170, y, { align: 'right' });
        y += 8;

        currentQuiz.subjects[subject].forEach((q, index) => {
            const response = userResponses[subject]?.[index]?.answer ?? "Not answered";
            let isCorrect = false;
            let correctAnswerText = '';
            let marksCorrect = currentQuiz.marksMode === 'custom' ? (q.correctMarks ?? 1) : (currentQuiz.correctMarks ?? 1);
            let marksIncorrect = currentQuiz.marksMode === 'custom' ? (q.wrongMarks ?? 0) : (currentQuiz.wrongMarks ?? 0);
            let marksObtained = 0;

            if (q.type === "multiple-choice") {
                correctAnswerText = q.options[q.correctAnswer];
                if (response === q.shuffledCorrectAnswerIndex) {
                    isCorrect = true;
                    marksObtained = marksCorrect;
                } else {
                    marksObtained = marksIncorrect;
                }
            } else if (q.type === "fill-in-the-blank") {
                const correctAnswers = (q.answerKey || '').split('|').map(a => a.trim().toLowerCase());
                correctAnswerText = correctAnswers.join(", ");
                if (correctAnswers.includes((response || '').toString().trim().toLowerCase())) {
                    isCorrect = true;
                    marksObtained = marksCorrect;
                } else {
                    marksObtained = marksIncorrect;
                }
            } else if (q.type === "subjective") {
                correctAnswerText = q.sampleAnswer || "N/A";
                marksObtained = userResponses[subject][index]?.marks || 0;
            }

            subjectScore += marksObtained;

            // Alternating row color
            if (index % 2 === 0) doc.setFillColor(245, 245, 245);
            else doc.setFillColor(255, 255, 255);
            doc.rect(10, y - 4, 190, 8, 'F');

            if (y + 10 > 280) {
                doc.addPage();
                y = 10;
            }

            doc.setTextColor(0, 0, 0);
            doc.text(`${index + 1}`, 12, y);
            doc.text(q.text.substring(0, 60), 20, y);
            doc.text(response.toString().substring(0, 40), 110, y);
            doc.text(correctAnswerText.substring(0, 30), 160, y);
            doc.text(marksObtained.toString(), 200, y, { align: 'right' });

            // Time spent per question
            const timeSpent = Math.floor((questionTimes[subject]?.[index] || 0) / 1000);
            doc.text(timeSpent.toString(), 170, y, { align: 'right' });

            y += 8;
        });

        totalScore += subjectScore;

        // Subject Score
        doc.setTextColor(0, 128, 0);
        doc.setFontStyle("bold");
        if (y + 10 > 280) {
            doc.addPage();
            y = 10;
        }
        doc.text(`Subject Score: ${subjectScore}`, 12, y);
        y += 12;
        doc.setFontStyle("normal");
    });

    // Total Score
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 128);
    if (y + 10 > 280) {
        doc.addPage();
        y = 10;
    }
    doc.text(`Total Score: ${totalScore}`, 12, y);
    y += 10;

    // Warnings / AI Alerts
    doc.setFontSize(12);
    doc.setTextColor(255, 0, 0);
    if (y + 10 > 280) {
        doc.addPage();
        y = 10;
    }
    doc.text(`Warnings Issued: ${warningCount} / ${maxWarnings}`, 12, y);
    y += 7;

    // Optional: add details of each warning if you maintain a warning log
    if (window.warningLog && warningLog.length > 0) {
        doc.setFontSize(11);
        warningLog.forEach((warn, idx) => {
            if (y + 10 > 280) {
                doc.addPage();
                y = 10;
            }
            doc.text(`${idx + 1}. ${warn}`, 12, y);
            y += 6;
        });
    }

    doc.save(`${studentDetails.name}_Exam_Report.pdf`);
}
loadInitialData();
Object.assign(window, {
  markForReview,
  manualSave,
  goPrevious,
  clearResponse,
  saveAndNext,
  confirmSubmit,
});

</script>
</body>
</html>
